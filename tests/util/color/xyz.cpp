// WARNING: This file was generated using AI and may contain inaccuracies or errors.
// It should be reviewed and tested thoroughly before use in production.

#include "specula/util/color/xyz.hpp"

#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_floating_point.hpp>

using namespace specula;
using namespace Catch::Matchers;

TEST_CASE("Xyz color operations", "[util][color]") {
  SECTION("Basic construction and component access") {
    Xyz c1;
    CHECK(c1.x == 0.0f);
    CHECK(c1.y == 0.0f);
    CHECK(c1.z == 0.0f);

    Xyz c2(1.0f, 2.0f, 3.0f);
    CHECK(c2.x == 1.0f);
    CHECK(c2.y == 2.0f);
    CHECK(c2.z == 3.0f);

    CHECK(c2[0] == 1.0f);
    CHECK(c2[1] == 2.0f);
    CHECK(c2[2] == 3.0f);

    c2[0] = 4.0f;
    c2[1] = 5.0f;
    c2[2] = 6.0f;
    CHECK(c2.x == 4.0f);
    CHECK(c2.y == 5.0f);
    CHECK(c2.z == 6.0f);
  }

  SECTION("from_xyY static constructor") {
    SECTION("Normal case") {
      Point2f chromaticity(0.3f, 0.6f);
      Float luminance = 2.0f;

      Xyz xyz = Xyz::from_xyY(chromaticity, luminance);

      CHECK_THAT(xyz.x, WithinAbs(1.0f, 0.0001f));
      CHECK_THAT(xyz.y, WithinAbs(2.0f, 0.0001f));
      CHECK_THAT(xyz.z, WithinAbs(0.333333f, 0.0001f));
    }

    SECTION("Zero y chromaticity") {
      Point2f chromaticity(0.3f, 0.0f);
      Xyz xyz = Xyz::from_xyY(chromaticity);

      CHECK(xyz.x == 0.0f);
      CHECK(xyz.y == 0.0f);
      CHECK(xyz.z == 0.0f);
    }

    SECTION("Default luminance") {
      Point2f chromaticity(0.3f, 0.6f);

      Xyz xyz = Xyz::from_xyY(chromaticity); // Default Y = 1

      CHECK_THAT(xyz.x, WithinAbs(0.5f, 0.0001f));
      CHECK_THAT(xyz.y, WithinAbs(1.0f, 0.0001f));
      CHECK_THAT(xyz.z, WithinAbs(0.166667f, 0.0001f));
    }
  }

  SECTION("Average computation") {
    Xyz c1(3.0f, 6.0f, 9.0f);
    CHECK_THAT(c1.average(), WithinAbs(6.0f, 0.0001f));

    Xyz c2(1.5f, 2.5f, 3.5f);
    CHECK_THAT(c2.average(), WithinAbs(2.5f, 0.0001f));
  }

  SECTION("Chromaticity conversion") {
    Xyz c(3.0f, 6.0f, 3.0f);
    Point2f chromaticity = c.xy();

    CHECK_THAT(chromaticity.x, WithinAbs(0.25f, 0.0001f));
    CHECK_THAT(chromaticity.y, WithinAbs(0.5f, 0.0001f));

    Xyz c2(0.0f, 0.0f, 0.0f);
    Point2f chromaticity2 = c2.xy();

    // When all values are 0, we expect NaN, but Catch doesn't handle NaN checks well,
    // so we'll just check if the result is non-finite
    CHECK_FALSE(std::isfinite(chromaticity2.x));
    CHECK_FALSE(std::isfinite(chromaticity2.y));
  }

  SECTION("Addition operations") {
    Xyz c1(1.0f, 2.0f, 3.0f);
    Xyz c2(4.0f, 5.0f, 6.0f);

    // Test operator+
    Xyz sum = c1 + c2;
    CHECK(sum.x == 5.0f);
    CHECK(sum.y == 7.0f);
    CHECK(sum.z == 9.0f);

    // Test operator+=
    Xyz c3 = c1;
    c3 += c2;
    CHECK(c3.x == 5.0f);
    CHECK(c3.y == 7.0f);
    CHECK(c3.z == 9.0f);
  }

  SECTION("Subtraction operations") {
    Xyz c1(10.0f, 20.0f, 30.0f);
    Xyz c2(1.0f, 2.0f, 3.0f);

    // Test operator-
    Xyz diff = c1 - c2;
    CHECK(diff.x == 9.0f);
    CHECK(diff.y == 18.0f);
    CHECK(diff.z == 27.0f);

    // Test operator-=
    Xyz c3 = c1;
    c3 -= c2;
    CHECK(c3.x == 9.0f);
    CHECK(c3.y == 18.0f);
    CHECK(c3.z == 27.0f);

    // Test scalar - Xyz
    Xyz result = 5.0f - c2;
    CHECK(result.x == 4.0f);
    CHECK(result.y == 3.0f);
    CHECK(result.z == 2.0f);
  }

  SECTION("Multiplication operations") {
    Xyz c1(2.0f, 3.0f, 4.0f);
    Xyz c2(3.0f, 4.0f, 5.0f);

    // Test Xyz * Xyz
    Xyz product = c1 * c2;
    CHECK(product.x == 6.0f);
    CHECK(product.y == 12.0f);
    CHECK(product.z == 20.0f);

    // Test Xyz *= Xyz
    Xyz c3 = c1;
    c3 *= c2;
    CHECK(c3.x == 6.0f);
    CHECK(c3.y == 12.0f);
    CHECK(c3.z == 20.0f);

    // Test Xyz * scalar
    Xyz scaled = c1 * 2.0f;
    CHECK(scaled.x == 4.0f);
    CHECK(scaled.y == 6.0f);
    CHECK(scaled.z == 8.0f);

    // Test scalar * Xyz
    Xyz scaled2 = 3.0f * c1;
    CHECK(scaled2.x == 6.0f);
    CHECK(scaled2.y == 9.0f);
    CHECK(scaled2.z == 12.0f);

    // Test Xyz *= scalar
    Xyz c4 = c1;
    c4 *= 2.0f;
    CHECK(c4.x == 4.0f);
    CHECK(c4.y == 6.0f);
    CHECK(c4.z == 8.0f);
  }

  SECTION("Division operations") {
    Xyz c1(6.0f, 8.0f, 10.0f);
    Xyz c2(2.0f, 4.0f, 5.0f);

    // Test Xyz / Xyz
    Xyz quotient = c1 / c2;
    CHECK(quotient.x == 3.0f);
    CHECK(quotient.y == 2.0f);
    CHECK(quotient.z == 2.0f);

    // Test Xyz /= Xyz
    Xyz c3 = c1;
    c3 /= c2;
    CHECK(c3.x == 3.0f);
    CHECK(c3.y == 2.0f);
    CHECK(c3.z == 2.0f);

    // Test Xyz / scalar
    Xyz scaled = c1 / 2.0f;
    CHECK(scaled.x == 3.0f);
    CHECK(scaled.y == 4.0f);
    CHECK(scaled.z == 5.0f);

    // Test Xyz /= scalar
    Xyz c4 = c1;
    c4 /= 2.0f;
    CHECK(c4.x == 3.0f);
    CHECK(c4.y == 4.0f);
    CHECK(c4.z == 5.0f);
  }

  SECTION("Unary negation") {
    Xyz c(1.0f, -2.0f, 3.0f);
    Xyz neg = -c;
    CHECK(neg.x == -1.0f);
    CHECK(neg.y == 2.0f);
    CHECK(neg.z == -3.0f);
  }

  SECTION("Equality and inequality operators") {
    Xyz c1(1.0f, 2.0f, 3.0f);
    Xyz c2(1.0f, 2.0f, 3.0f);
    Xyz c3(3.0f, 2.0f, 1.0f);

    CHECK(c1 == c2);
    CHECK(c1 != c3);
    CHECK(c2 != c3);
  }

  SECTION("Utility functions") {
    SECTION("clamp") {
      Xyz c(-1.0f, 0.5f, 2.0f);

      Xyz result = clamp(c, 0.0f, 1.0f);
      CHECK(result.x == 0.0f);
      CHECK(result.y == 0.5f);
      CHECK(result.z == 1.0f);
    }

    SECTION("clamp_zero") {
      Xyz c(-1.0f, 0.0f, 2.0f);

      Xyz result = clamp_zero(c);
      CHECK(result.x == 0.0f);
      CHECK(result.y == 0.0f);
      CHECK(result.z == 2.0f);
    }

    SECTION("lerp") {
      Xyz c1(0.0f, 10.0f, 20.0f);
      Xyz c2(10.0f, 20.0f, 30.0f);

      // Test t=0 (should be c1)
      Xyz result1 = lerp(0.0f, c1, c2);
      CHECK(result1.x == c1.x);
      CHECK(result1.y == c1.y);
      CHECK(result1.z == c1.z);

      // Test t=1 (should be c2)
      Xyz result2 = lerp(1.0f, c1, c2);
      CHECK(result2.x == c2.x);
      CHECK(result2.y == c2.y);
      CHECK(result2.z == c2.z);

      // Test t=0.5 (should be midpoint)
      Xyz result3 = lerp(0.5f, c1, c2);
      CHECK(result3.x == 5.0f);
      CHECK(result3.y == 15.0f);
      CHECK(result3.z == 25.0f);
    }
  }
}
