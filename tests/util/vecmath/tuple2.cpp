// WARNING: This file was generated using AI and may contain inaccuracies or errors.
// It should be reviewed and tested thoroughly before use in production.

#include "specula/util/vecmath/tuple2.hpp"

#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_floating_point.hpp>

using namespace specula;
using namespace Catch::Matchers;

TEST_CASE("Tuple2", "[util][vecmath]") {
  SECTION("Basic operations") {
    Vector2f v1(1.0f, 2.0f);
    Vector2f v2(3.0f, 4.0f);

    // Test basic operations
    CHECK(v1 + v2 == Vector2f(4.0f, 6.0f));
    CHECK(v2 - v1 == Vector2f(2.0f, 2.0f));
    CHECK(v1 * 2.0f == Vector2f(2.0f, 4.0f));
    CHECK(2.0f * v1 == Vector2f(2.0f, 4.0f));
    CHECK(v2 / 2.0f == Vector2f(1.5f, 2.0f));

    // Test compound assignment
    Vector2f v3 = v1;
    v3 += v2;
    CHECK(v3 == Vector2f(4.0f, 6.0f));

    v3 = v2;
    v3 -= v1;
    CHECK(v3 == Vector2f(2.0f, 2.0f));

    v3 = v1;
    v3 *= 2.0f;
    CHECK(v3 == Vector2f(2.0f, 4.0f));

    v3 = v2;
    v3 /= 2.0f;
    CHECK(v3 == Vector2f(1.5f, 2.0f));

    // Test equality operators
    CHECK(v1 == Vector2f(1.0f, 2.0f));
    CHECK(v1 != v2);

    // Test negation
    CHECK(-v1 == Vector2f(-1.0f, -2.0f));

    // Test indexing
    CHECK(v1[0] == 1.0f);
    CHECK(v1[1] == 2.0f);
  }

  SECTION("Helper functions") {
    Vector2f v1(-1.5f, 2.3f);
    Vector2f v2(3.2f, 1.0f);

    // Test abs
    CHECK(abs(v1) == Vector2f(1.5f, 2.3f));

    // Test ceil and floor
    CHECK(ceil(v1) == Vector2f(-1.0f, 3.0f));
    CHECK(floor(v1) == Vector2f(-2.0f, 2.0f));

    // Test lerp
    Vector2f lerp_result = lerp(0.5f, v1, v2);
    CHECK_THAT(lerp_result.x, WithinAbs(0.85f, 0.00001f));
    CHECK_THAT(lerp_result.y, WithinAbs(1.65f, 0.00001f));

    // Test min/max
    CHECK(min(v1, v2) == Vector2f(-1.5f, 1.0f));
    CHECK(max(v1, v2) == Vector2f(3.2f, 2.3f));

    // Test component functions
    CHECK(min_component_value(v1) == -1.5f);
    CHECK(max_component_value(v1) == 2.3f);
    CHECK(min_component_index(v1) == 0);
    CHECK(max_component_index(v1) == 1);

    // Test permute
    CHECK(permute(v1, {1, 0}) == Vector2f(2.3f, -1.5f));

    // Test horizontal product
    CHECK_THAT(hprod(v1), WithinAbs(-3.45f, 0.00001f));
  }
}

TEST_CASE("Vector2", "[util][vecmath]") {
  SECTION("Constructors and conversions") {
    // Basic constructor
    Vector2f v1(1.0f, 2.0f);
    CHECK(v1.x == 1.0f);
    CHECK(v1.y == 2.0f);

    // Type conversion constructor
    Vector2i vi(3, 4);
    Vector2f vf(vi);
    CHECK(vf.x == 3.0f);
    CHECK(vf.y == 4.0f);

    // Point to Vector conversion
    Point2f p(5.0f, 6.0f);
    Vector2f vp(p);
    CHECK(vp.x == 5.0f);
    CHECK(vp.y == 6.0f);
  }
}

TEST_CASE("Point2", "[util][vecmath]") {
  SECTION("Basic operations") {
    Point2f p1(1.0f, 2.0f);
    Point2f p2(3.0f, 4.0f);
    Vector2f v(2.0f, 3.0f);

    // Test addition with vector
    CHECK(p1 + v == Point2f(3.0f, 5.0f));

    // Test compound addition with vector
    Point2f p3 = p1;
    p3 += v;
    CHECK(p3 == Point2f(3.0f, 5.0f));

    // Test subtraction of points (yielding a vector)
    Vector2f v_diff = p2 - p1;
    CHECK(v_diff == Vector2f(2.0f, 2.0f));

    // Test point minus vector (yielding a point)
    CHECK(p2 - v == Point2f(1.0f, 1.0f));

    // Test compound subtraction with vector
    p3 = p2;
    p3 -= v;
    CHECK(p3 == Point2f(1.0f, 1.0f));

    // Test negation
    CHECK(-p1 == Point2f(-1.0f, -2.0f));

    // Test scalar multiplication
    CHECK(p1 * 2.0f == Point2f(2.0f, 4.0f));
    CHECK(2.0f * p1 == Point2f(2.0f, 4.0f));

    // Test compound scalar multiplication
    p3 = p1;
    p3 *= 2.0f;
    CHECK(p3 == Point2f(2.0f, 4.0f));
  }

  SECTION("Conversions") {
    // Convert between types
    Point2i pi(1, 2);
    Point2f pf(pi);
    CHECK(pf.x == 1.0f);
    CHECK(pf.y == 2.0f);

    // Vector to Point conversion
    Vector2f v(3.0f, 4.0f);
    Point2f p(v);
    CHECK(p.x == 3.0f);
    CHECK(p.y == 4.0f);
  }
}
