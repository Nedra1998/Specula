// WARNING: This file was generated using AI and may contain inaccuracies or errors.
// It should be reviewed and tested thoroughly before use in production.

#include "specula/util/vecmath/bounds2.hpp"

#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_floating_point.hpp>

using namespace specula;
using namespace Catch::Matchers;

TEST_CASE("Bounds2", "[util][vecmath]") {
  SECTION("Constructors") {
    // Default constructor
    Bounds2f b1;
    CHECK(b1.is_empty());

    // Single point constructor
    Point2f p1(1.0f, 2.0f);
    Bounds2f b2(p1);
    CHECK(b2.pmin == p1);
    CHECK(b2.pmax == p1);
    CHECK(b2.is_empty());

    // Two points constructor
    Point2f p2(3.0f, 4.0f);
    Bounds2f b3(p1, p2);
    CHECK(b3.pmin == Point2f(1.0f, 2.0f));
    CHECK(b3.pmax == Point2f(3.0f, 4.0f));
    CHECK(!b3.is_empty());

    // Two points constructor with reversed coordinates
    Point2f p3(-1.0f, 5.0f);
    Bounds2f b4(p2, p3);
    CHECK(b4.pmin == Point2f(-1.0f, 4.0f));
    CHECK(b4.pmax == Point2f(3.0f, 5.0f));

    // Type conversion constructor
    Bounds2i bi(Point2i(1, 2), Point2i(3, 4));
    Bounds2f bf(bi);
    CHECK(bf.pmin == Point2f(1.0f, 2.0f));
    CHECK(bf.pmax == Point2f(3.0f, 4.0f));

    // Type conversion from empty bounds
    Bounds2i empty_bi;
    Bounds2f empty_bf(empty_bi);
    CHECK(empty_bf.is_empty());
  }

  SECTION("Methods") {
    Point2f p1(1.0f, 2.0f);
    Point2f p2(4.0f, 6.0f);
    Bounds2f b(p1, p2);

    // Diagonal
    CHECK(b.diagonal() == Vector2f(3.0f, 4.0f));

    // Area
    CHECK_THAT(b.area(), WithinAbs(12.0f, 0.00001f));

    // Empty and degenerate
    CHECK(!b.is_empty());
    CHECK(!b.is_degenerate());

    // Max dimension
    CHECK(b.max_dimension() == 1); // y dimension is larger

    Bounds2f bx(Point2f(1.0f, 2.0f), Point2f(5.0f, 3.0f));
    CHECK(bx.max_dimension() == 0); // x dimension is larger

    // Corner
    CHECK(b.corner(0) == Point2f(1.0f, 2.0f)); // min-min
    CHECK(b.corner(1) == Point2f(4.0f, 2.0f)); // max-min
    CHECK(b.corner(2) == Point2f(1.0f, 6.0f)); // min-max
    CHECK(b.corner(3) == Point2f(4.0f, 6.0f)); // max-max

    // Lerp
    CHECK(b.lerp(Point2f(0.0f, 0.0f)) == Point2f(1.0f, 2.0f));
    CHECK(b.lerp(Point2f(1.0f, 1.0f)) == Point2f(4.0f, 6.0f));
    CHECK(b.lerp(Point2f(0.5f, 0.5f)) == Point2f(2.5f, 4.0f));

    // Offset
    CHECK(b.offset(Point2f(1.0f, 2.0f)) == Vector2f(0.0f, 0.0f));
    CHECK(b.offset(Point2f(4.0f, 6.0f)) == Vector2f(1.0f, 1.0f));
    CHECK(b.offset(Point2f(2.5f, 4.0f)) == Vector2f(0.5f, 0.5f));

    // Bounding sphere
    Point2f center;
    Float radius;
    b.bounding_sphere(&center, &radius);
    CHECK(center == Point2f(2.5f, 4.0f));
    CHECK_THAT(radius, WithinAbs(2.5f, 0.00001f));

    // Operator []
    CHECK(b[0] == p1);
    CHECK(b[1] == p2);

    // Equality operators
    Bounds2f b2(p1, p2);
    CHECK(b == b2);
    CHECK(!(b != b2));
    Bounds2f b3(Point2f(0.0f, 2.0f), p2);
    CHECK(b != b3);
    CHECK(!(b == b3));
  }

  SECTION("Utility functions") {
    Point2f p1(1.0f, 2.0f);
    Point2f p2(4.0f, 6.0f);
    Point2f p3(0.0f, 1.0f);
    Point2f p4(5.0f, 7.0f);
    Bounds2f b1(p1, p2);
    Bounds2f b2(p3, p4);

    // Bounds union
    Bounds2f union_b = bounds_union(b1, b2);
    CHECK(union_b.pmin == Point2f(0.0f, 1.0f));
    CHECK(union_b.pmax == Point2f(5.0f, 7.0f));

    // Bounds-Point union
    Bounds2f union_p = bounds_union(b1, Point2f(-1.0f, 8.0f));
    CHECK(union_p.pmin == Point2f(-1.0f, 2.0f));
    CHECK(union_p.pmax == Point2f(4.0f, 8.0f));

    // Intersection
    Bounds2f intersect_b = intersect(b1, b2);
    CHECK(intersect_b.pmin == Point2f(1.0f, 2.0f));
    CHECK(intersect_b.pmax == Point2f(4.0f, 6.0f));

    // No intersection case
    Bounds2f b3(Point2f(10.0f, 10.0f), Point2f(20.0f, 20.0f));
    Bounds2f no_intersect = intersect(b1, b3);
    CHECK(no_intersect.is_empty());

    // Overlaps
    CHECK(overlaps(b1, b2));
    CHECK(!overlaps(b1, b3));

    // Inside (Point in Bounds)
    CHECK(inside(Point2f(2.0f, 3.0f), b1));
    CHECK(!inside(Point2f(0.0f, 0.0f), b1));

    // Inside (Bounds in Bounds)
    Bounds2f b4(Point2f(2.0f, 3.0f), Point2f(3.0f, 5.0f));
    CHECK(inside(b4, b1));
    CHECK(!inside(b1, b4));

    // Inside exclusive
    CHECK(inside_exclusive(Point2f(2.0f, 3.0f), b1));
    CHECK(!inside_exclusive(Point2f(4.0f, 6.0f), b1));

    // Expand
    Bounds2f expanded = expand(b1, 2.0f);
    CHECK(expanded.pmin == Point2f(-1.0f, 0.0f));
    CHECK(expanded.pmax == Point2f(6.0f, 8.0f));
  }
}
