// WARNING: This file was generated using AI and may contain inaccuracies or errors.
// It should be reviewed and tested thoroughly before use in production.

#include "specula/util/vecmath/quaternion.hpp"

#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_floating_point.hpp>

using namespace specula;
using namespace Catch::Matchers;

TEST_CASE("Quaternion", "[util][vecmath]") {
  SECTION("Constructors") {
    // Default constructor
    Quaternion q1;
    CHECK(q1.v == Vector3f(0.0f, 0.0f, 0.0f));
    CHECK(q1.w == 1.0f);

    // Parameterized constructor
    Vector3f v(1.0f, 2.0f, 3.0f);
    Quaternion q2(v, 4.0f);
    CHECK(q2.v == v);
    CHECK(q2.w == 4.0f);
  }

  SECTION("Basic operations") {
    Vector3f v1(1.0f, 2.0f, 3.0f);
    Vector3f v2(4.0f, 5.0f, 6.0f);
    Quaternion q1(v1, 7.0f);
    Quaternion q2(v2, 8.0f);

    // Addition
    Quaternion q3 = q1 + q2;
    CHECK(q3.v == Vector3f(5.0f, 7.0f, 9.0f));
    CHECK(q3.w == 15.0f);

    // Compound addition
    Quaternion q4 = q1;
    q4 += q2;
    CHECK(q4.v == Vector3f(5.0f, 7.0f, 9.0f));
    CHECK(q4.w == 15.0f);

    // Negation
    Quaternion q5 = -q1;
    CHECK(q5.v == Vector3f(-1.0f, -2.0f, -3.0f));
    CHECK(q5.w == -7.0f);

    // Subtraction
    Quaternion q6 = q2 - q1;
    CHECK(q6.v == Vector3f(3.0f, 3.0f, 3.0f));
    CHECK(q6.w == 1.0f);

    // Compound subtraction
    Quaternion q7 = q2;
    q7 -= q1;
    CHECK(q7.v == Vector3f(3.0f, 3.0f, 3.0f));
    CHECK(q7.w == 1.0f);

    // Scalar multiplication
    Quaternion q8 = q1 * 2.0f;
    CHECK(q8.v == Vector3f(2.0f, 4.0f, 6.0f));
    CHECK(q8.w == 14.0f);

    // Scalar multiplication from left
    Quaternion q9 = 2.0f * q1;
    CHECK(q9.v == Vector3f(2.0f, 4.0f, 6.0f));
    CHECK(q9.w == 14.0f);

    // Compound scalar multiplication
    Quaternion q10 = q1;
    q10 *= 2.0f;
    CHECK(q10.v == Vector3f(2.0f, 4.0f, 6.0f));
    CHECK(q10.w == 14.0f);

    // Scalar division
    Quaternion q11 = q1 / 2.0f;
    CHECK(q11.v == Vector3f(0.5f, 1.0f, 1.5f));
    CHECK(q11.w == 3.5f);

    // Compound scalar division
    Quaternion q12 = q1;
    q12 /= 2.0f;
    CHECK(q12.v == Vector3f(0.5f, 1.0f, 1.5f));
    CHECK(q12.w == 3.5f);
  }
}

TEST_CASE("Quaternion helper functions", "[util][vecmath]") {
  SECTION("Dot product") {
    Vector3f v1(1.0f, 2.0f, 3.0f);
    Vector3f v2(4.0f, 5.0f, 6.0f);
    Quaternion q1(v1, 7.0f);
    Quaternion q2(v2, 8.0f);

    Float result = dot(q1, q2);
    // dot(q1, q2) = dot(v1, v2) + w1 * w2
    //             = (1*4 + 2*5 + 3*6) + 7*8
    //             = (4 + 10 + 18) + 56
    //             = 32 + 56
    //             = 88
    CHECK_THAT(result, WithinAbs(88.0f, 0.00001f));
  }

  SECTION("Length") {
    Vector3f v(1.0f, 2.0f, 2.0f);
    Quaternion q(v, 4.0f);

    Float result = length(q);
    // length(q) = sqrt(dot(q, q))
    //           = sqrt((1*1 + 2*2 + 2*2) + 4*4)
    //           = sqrt(1 + 4 + 4 + 16)
    //           = sqrt(25)
    //           = 5
    CHECK_THAT(result, WithinAbs(5.0f, 0.00001f));
  }

  SECTION("Normalize") {
    Vector3f v(3.0f, 0.0f, 4.0f);
    Quaternion q(v, 0.0f);

    Quaternion normalized = normalize(q);
    // length(q) = sqrt(dot(q, q))
    //           = sqrt((3*3 + 0*0 + 4*4) + 0*0)
    //           = sqrt(9 + 0 + 16 + 0)
    //           = sqrt(25)
    //           = 5
    // normalize(q) = q / length(q) = q / 5
    CHECK_THAT(normalized.v.x, WithinAbs(0.6f, 0.00001f));
    CHECK_THAT(normalized.v.y, WithinAbs(0.0f, 0.00001f));
    CHECK_THAT(normalized.v.z, WithinAbs(0.8f, 0.00001f));
    CHECK_THAT(normalized.w, WithinAbs(0.0f, 0.00001f));
    CHECK_THAT(length(normalized), WithinAbs(1.0f, 0.00001f));
  }

  SECTION("Angle between") {
    // Create two simple quaternions
    Vector3f v1(1.0f, 0.0f, 0.0f);
    Vector3f v2(0.0f, 1.0f, 0.0f);
    Quaternion q1(v1, 0.0f);
    Quaternion q2(v2, 0.0f);

    // Normalize them
    q1 = normalize(q1);
    q2 = normalize(q2);

    Float angle = angle_between(q1, q2);
    // For unit quaternions, this should be related to the angle between their orientations
    // Since these represent 90-degree rotations around different axes, we expect a value
    CHECK(angle > 0.0f);
  }

  SECTION("Slerp") {
    // Create two quaternions
    Vector3f v1(1.0f, 0.0f, 0.0f);
    Vector3f v2(0.0f, 1.0f, 0.0f);
    Quaternion q1(v1, 0.0f);
    Quaternion q2(v2, 0.0f);

    // Normalize them
    q1 = normalize(q1);
    q2 = normalize(q2);

    // Test slerp with t = 0 (should be q1)
    Quaternion interpolated1 = slerp(0.0f, q1, q2);
    CHECK_THAT(interpolated1.v.x, WithinAbs(q1.v.x, 0.00001f));
    CHECK_THAT(interpolated1.v.y, WithinAbs(q1.v.y, 0.00001f));
    CHECK_THAT(interpolated1.v.z, WithinAbs(q1.v.z, 0.00001f));
    CHECK_THAT(interpolated1.w, WithinAbs(q1.w, 0.00001f));

    // Test slerp with t = 1 (should be q2)
    Quaternion interpolated2 = slerp(1.0f, q1, q2);
    CHECK_THAT(interpolated2.v.x, WithinAbs(q2.v.x, 0.00001f));
    CHECK_THAT(interpolated2.v.y, WithinAbs(q2.v.y, 0.00001f));
    CHECK_THAT(interpolated2.v.z, WithinAbs(q2.v.z, 0.00001f));
    CHECK_THAT(interpolated2.w, WithinAbs(q2.w, 0.00001f));

    // Test slerp with t = 0.5 (should be halfway between)
    Quaternion interpolated3 = slerp(0.5f, q1, q2);
    CHECK_THAT(length(interpolated3), WithinAbs(1.0f, 0.00001f)); // Result should be normalized
  }

  SECTION("Format as") {
    Vector3f v(1.0f, 2.0f, 3.0f);
    Quaternion q(v, 4.0f);

    auto formatted = format_as(q);
    CHECK(formatted[0] == 1.0f);
    CHECK(formatted[1] == 2.0f);
    CHECK(formatted[2] == 3.0f);
    CHECK(formatted[3] == 4.0f);
  }
}